# coding: utf-8
# 
#
# user-graph need to be generated by the following script
# tools/generate-u-u-matrix.py
#
# item-item graph need to be generated by the following script
# tools/generate-c-c-matrix.py
import os
import numpy as np
import pandas as pd
import scipy.sparse as sp
import torch
import torch.nn as nn
import torch.nn.functional as F
from torch_geometric.nn.conv import MessagePassing
from torch_geometric.utils import remove_self_loops, add_self_loops, degree
from torch_geometric.nn import GATConv

from common.abstract_recommender import GeneralRecommender
from common.loss import BPRLoss, EmbLoss
from common.init import xavier_uniform_initialization


class KSE(GeneralRecommender):
    def __init__(self, config, dataset):
        super(KSE, self).__init__(config, dataset)
        batch_size = config['train_batch_size']
        dim_x = config['embedding_size']
        self.feat_embed_dim = config['feat_embed_dim']
        self.n_layers = config['n_mm_layers']
        self.knn_k = config['knn_k'] # for item
        self.mm_image_weight = config['mm_image_weight']
        has_id = True
        self.batch_size = batch_size
        self.k = 40 # for user
        self.aggr_mode = config['aggr_mode']
        self.user_aggr_mode = 'softmax'
        self.num_layer = 1
        self.cold_start = 0
        self.dataset = dataset
        self.construction = 'cat'
        self.reg_weight = config['reg_weight']
        self.drop_rate = 0.1
        self.v_rep = None
        self.t_rep = None
        self.v_preference = None
        self.t_preference = None
        self.dim_latent = 64
        self.dim_feat = 128
        self.co_adj = None

        # load dataset
        dataset_path = os.path.abspath(config['data_path'] + config['dataset'])
        self.item_graph_dict = np.load(os.path.join(dataset_path, config['item_graph_dict_file']), allow_pickle=True).item()
        self.user_item_dict = np.load(os.path.join(dataset_path, config['user_item_dict_file']), allow_pickle=True).item()
        self.num_user = len(self.user_item_dict.keys())
        self.num_item = len(self.item_graph_dict.keys())
        print('number of users:', self.num_user)
        print('number of item', self.num_item)

        # TODO(bt-nghia): add weights
        # TODO(bt-nghia): load/construct item co-occurent matrix
        self.vt_feat = torch.concat([config['text_weight'] * self.t_feat, config['visual_weight'] * self.v_feat], dim=1)

        # packing interaction in training into edge_index
        self.load_u_i_edge('data/instacart/interaction.csv')

        self.weight_u = nn.Parameter(nn.init.xavier_normal_(
            torch.tensor(np.random.randn(self.num_user, 2, 1), dtype=torch.float32, requires_grad=True)))
        self.weight_u.data = F.softmax(self.weight_u, dim=1)

        self.weight_i = nn.Parameter(nn.init.xavier_normal_(
            torch.tensor(np.random.randn(self.num_item, 2, 1), dtype=torch.float32, requires_grad=True)))
        self.weight_i.data = F.softmax(self.weight_i, dim=1)

        self.item_index = torch.zeros([self.num_item], dtype=torch.long)
        #TODO(bt-nghia): GCN for vt_feat
        self.user_feat = self.mean_items(self.vt_feat)
        if self.vt_feat is not None:
            # GCN
            self.vt_gcn = GCN(self.dataset, batch_size, self.num_user, self.num_item, dim_x, self.aggr_mode,
                              num_layer=self.num_layer, has_id=has_id, dropout=self.drop_rate, dim_latent=64,
                              device=self.device, features=self.vt_feat, user_feat=self.user_feat)
        self.item_graph = Item_Graph_sample(self.num_item, 'add', self.dim_latent)
        

    def get_knn_adj_mat(self, mm_embeddings):
        context_norm = mm_embeddings.div(torch.norm(mm_embeddings, p=2, dim=-1, keepdim=True))
        sim = torch.mm(context_norm, context_norm.transpose(1, 0))
        _, knn_ind = torch.topk(sim, self.knn_k, dim=-1)
        adj_size = sim.size()
        del sim
        # construct sparse adj
        indices0 = torch.arange(knn_ind.shape[0]).to(self.device)
        indices0 = torch.unsqueeze(indices0, 1)
        indices0 = indices0.expand(-1, self.knn_k)
        indices = torch.stack((torch.flatten(indices0), torch.flatten(knn_ind)), 0)
        # norm
        return indices, self.compute_normalized_laplacian(indices, adj_size)
    
    
    def compute_normalized_laplacian(self, indices, adj_size):
        adj = torch.sparse.FloatTensor(indices, torch.ones_like(indices[0]), adj_size)
        row_sum = 1e-7 + torch.sparse.sum(adj, -1).to_dense()
        r_inv_sqrt = torch.pow(row_sum, -0.5)
        rows_inv_sqrt = r_inv_sqrt[indices[0]]
        cols_inv_sqrt = r_inv_sqrt[indices[1]]
        values = rows_inv_sqrt * cols_inv_sqrt
        return torch.sparse.FloatTensor(indices, values, adj_size)
    
    def mean_items(self, item_feat):
        # user_item_dict ex: user[0] = [1,2,3,6,7,...]
        user_feat = []
        u_dim = item_feat.shape[1]
        n_user = len(self.user_item_dict.keys())
        for i in range(n_user):
            item_inter = item_feat[self.user_item_dict[i]]
            user_feat.append(torch.mean(item_inter, dim=0))
        user_feat = torch.cat(user_feat, dim=0)
        user_feat = user_feat.view(n_user, u_dim)
        print('calculate means items done')
        return user_feat
    
    def pre_epoch_processing(self):
        self.epoch_item_graph, self.item_weight_matrix = self.topk_sample_item(self.k)
        self.item_edge_index = self.construct_index(self.epoch_item_graph).to(self.device)
        self.item_weight_matrix = self.item_weight_matrix.to(self.device)

    def pack_edge_index(self, inter_mat):
        rows = inter_mat.row
        cols = inter_mat.col + self.n_users
        # ndarray([598918, 2]) for ml-imdb
        return np.column_stack((rows, cols))

    #TODO(bt-nghia) : merge 2 function
    def construct_index(self, item_graph):
        node1, node2 = [], []
        n_item = len(item_graph)
        for i in range(0, n_item):
            for j in item_graph[i]:
                node1.append(i)
                node2.append(j)
        edge_index = torch.tensor([node1, node2])
        edge_index = torch.cat((edge_index, edge_index[[1,0]]), dim=1)
        return edge_index


    def forward(self, interaction):
        item_nodes, pos_item_nodes, neg_item_nodes = interaction[0], interaction[1], interaction[2]
        item_nodes += self.num_user
        pos_item_nodes += self.num_user
        neg_item_nodes += self.num_user
        representation = None
        
        if self.vt_feat is not None:
            self.vt_rep, self.vt_preference = self.vt_gcn(self.edge_index, self.vt_feat)
            representation = self.vt_rep
        if self.construction == 'cat':
            if self.vt_rep is not None:
                user_rep = self.vt_rep[:self.num_user]

        item_rep = representation[self.num_user:]
        ############################################ multi-modal information aggregation
        h = self.item_graph(item_rep, self.epoch_item_graph, self.item_weight_matrix)
        item_rep = item_rep + h
        # interaction item_id += num_user concat to get item (itemid=itemid+n_users)
        self.result_embed = torch.cat((user_rep, item_rep), dim=0)
        item_tensor = self.result_embed[item_nodes]
        pos_item_tensor = self.result_embed[pos_item_nodes]
        neg_item_tensor = self.result_embed[neg_item_nodes]

        pos_scores = torch.sum(item_tensor * pos_item_tensor, dim=1)
        neg_scores = torch.sum(item_tensor * neg_item_tensor, dim=1)
        print('forward complete')
        return pos_scores, neg_scores

    def calculate_loss(self, interaction, gamma=1e-10):
        #bpr loss + reg
        item = interaction[0] + self.num_user
        pos_scores, neg_scores = self.forward(interaction)
        loss_value = -torch.mean(torch.log2(torch.sigmoid(pos_scores - neg_scores) + gamma))
        reg_emb_loss_vt = (self.vt_rep[item] ** 2).mean() if self.vt_rep is not None else 0.0

        reg_loss = self.reg_weight * (reg_emb_loss_vt)
        if self.construction == 'weighted_sum':
            reg_loss += self.reg_weight * (self.weight_u ** 2).mean()
            reg_loss += self.reg_weight * (self.weight_i ** 2).mean()
        elif self.construction == 'cat':
            reg_loss += self.reg_weight * (self.weight_u ** 2).mean()
        elif self.construction == 'cat_mlp':
            reg_loss += self.reg_weight * (self.MLP_user.weight ** 2).mean()
        return loss_value + reg_loss

    def full_sort_predict(self, interaction):
        user_tensor = self.result_embed[:self.n_users]
        item_tensor = self.result_embed[self.n_users:]

        temp_user_tensor = user_tensor[interaction[0], :]
        score_matrix = torch.matmul(temp_user_tensor, item_tensor.t())
        return score_matrix
    
    def i_i_sim(self):
        r'''
            batch_order : a batch of test/valid orders
            random 
        '''
        item_tensor = self.result_embed[self.num_user:]
        item_item_score = torch.matmul(item_tensor, item_tensor.T)
        return item_item_score

    
    def topk_sample_item(self, k):
        item_graph_index = []
        count_num = 0
        item_weight_matrix = torch.zeros(len(self.item_graph_dict), k)
        tasike = [0] * k
        for i in range(len(self.item_graph_dict)):
            if len(self.item_graph_dict[i][0]) < k:
                count_num += 1
                if len(self.item_graph_dict[i][0]) == 0:
                    item_graph_index.append(tasike)
                    continue
                item_graph_sample = self.item_graph_dict[i][0][:k]
                item_graph_weight = self.item_graph_dict[i][0][:k]

                while len(item_graph_sample) < k:
                    rand_id = np.random.randint(0, len(item_graph_sample))
                    item_graph_sample.append(item_graph_sample[rand_id])
                    item_graph_weight.append(item_graph_weight[rand_id])

                item_graph_index.append(item_graph_sample)

                #softmax
                item_weight_matrix[i] = F.softmax(torch.tensor(item_graph_weight), dim=0)
                continue
            item_graph_sample = self.item_graph_dict[i][0][:k]
            item_graph_weight = self.item_graph_dict[i][1][:k]

            item_weight_matrix[i] = F.softmax(torch.tensor(item_graph_weight), dim=0)
            item_graph_index.append(item_graph_sample)

        return item_graph_index, item_weight_matrix

    
    def load_u_i_edge(self, path, cols=('user_id', 'aisle_id')):
        self.user_item_edge = pd.read_csv(path, sep='\t')
        self.user_id = self.user_item_edge[cols[0]].to_numpy()
        self.item_id = self.user_item_edge[cols[1]].to_numpy() + self.num_user # stack user above item
        edge_index = np.array([self.user_id, self.item_id])
        self.edge_index = torch.tensor(edge_index, dtype=torch.long).contiguous().to(self.device) #edge_index is user_item edge
        self.edge_index = torch.cat((self.edge_index, self.edge_index[[1, 0]]), dim=1)
        # print(self.edge_index.shape)

    
class Item_Graph_sample(torch.nn.Module):
    def __init__(self, num_item, aggr_mode, dim_latent) -> None:
        super(Item_Graph_sample, self).__init__()
        self.num_item = num_item
        self.dim_latent = dim_latent
        self.aggr_mode = aggr_mode

    def forward(self, features, item_graph_edge, item_weight_mat):
        index = item_graph_edge
        i_feat = features[index]
        item_mat = item_weight_mat.unsqueeze(1)
        i_pre = torch.matmul(item_mat, i_feat)
        i_pre = i_pre.squeeze()
        return i_pre


class GCN(torch.nn.Module):
    def __init__(self,datasets, batch_size, num_user, num_item, dim_id, aggr_mode, num_layer, has_id, dropout,
                 dim_latent=None,device = None,features=None, user_feat=None):
        super(GCN, self).__init__()
        self.batch_size = batch_size
        self.num_user = num_user
        self.num_item = num_item
        self.datasets = datasets
        self.dim_id = dim_id
        self.dim_feat = features.size(1)
        self.dim_latent = dim_latent
        self.aggr_mode = aggr_mode
        self.num_layer = num_layer
        self.has_id = has_id
        self.dropout = dropout
        self.device = device
        self.u_dim = user_feat.size(1)

        if self.dim_latent:
            self.preference = user_feat.clone().detach().requires_grad_(True).to(self.device)
            self.MLP_user = nn.Linear(self.u_dim, dim_latent)
            self.MLP = nn.Linear(self.u_dim, 4*self.dim_latent)
            self.MLP_1 = nn.Linear(4*self.dim_latent, self.dim_latent)
            self.conv_embed_1 = Base_gcn(self.dim_latent, self.dim_latent, aggr=self.aggr_mode)

        else:
            self.preference = nn.Parameter(torch.tensor(user_feat)).to(self.device)
            self.conv_embed_1 = Base_gcn(self.dim_latent, self.dim_latent, aggr=self.aggr_mode)

    def forward(self, edge_index, features):
        temp_features = self.MLP_1(F.leaky_relu(self.MLP(features))) if self.dim_latent else features
        temp_preference = self.MLP_user(self.preference)
        x = torch.cat((temp_preference, temp_features), dim=0).to(self.device)
        x = F.normalize(x).to(self.device)
        h = self.conv_embed_1(x, edge_index)  # equation 1
        h_1 = self.conv_embed_1(h, edge_index)

        x_hat =h + x +h_1
        return x_hat, self.preference


class GAT(torch.nn.Module):
    def __init__(self,datasets, batch_size, num_user, num_item, dim_id, aggr_mode, num_layer, has_id, dropout,
                 dim_latent=None,device = None,features=None, dim_feat=None):
        super(GAT, self).__init__()
        self.batch_size = batch_size
        self.num_user = num_user
        self.num_item = num_item
        self.datasets = datasets
        self.dim_id = dim_id
        self.dim_feat = dim_feat
        self.dim_latent = dim_latent
        self.aggr_mode = aggr_mode
        self.num_layer = num_layer
        self.has_id = has_id
        self.dropout = dropout
        self.device = device
        self.n_head = 1
        self.add_self_loops = False
        self.concatnation = True
        self.n_layer = 2
        
        # if self.dim_latent:
        self.preference = nn.Parameter(nn.init.xavier_normal_(torch.tensor(
            np.random.randn(num_user, self.dim_latent), dtype=torch.float32, requires_grad=True),
            gain=1).to(self.device))
        self.MLP = nn.Linear(self.dim_feat, 4*self.dim_latent)
        self.MLP_1 = nn.Linear(4*self.dim_latent, self.dim_latent)
        # self.gatConv = GATConv(self.dim_latent, self.dim_latent, aggr=self.aggr_mode, heads=self.n_head)
        # self.gat = nn.ModuleList([GATConv(self.dim_latent, self.dim_latent, heads=self.n_head, add_self_loops=self.add_self_loops, concat=self.concatenation) for _ in range(self.n_layer)]) 
        # if there are more layers you can use modulelist
        self.gat1 = GATConv(self.dim_latent, self.dim_latent, heads=self.n_head, add_self_loops=self.add_self_loops, concat=self.concatnation)
        self.gat2 = GATConv(self.dim_latent, self.dim_latent, heads=self.n_head, add_self_loops=self.add_self_loops, concat=self.concatnation)
        
    def forward(self, edge_index, features):
        # edge_index_drop is redundant
        neigh_feat = self.MLP_1(F.leaky_relu(self.MLP(features))) if self.dim_latent else features
        x = torch.cat((self.preference, neigh_feat), dim=0).to(self.device) 
        x = F.normalize(x).to(self.device)
        h = self.gat1(x, edge_index=edge_index)
        h1 = self.gat2(h, edge_index=edge_index)
        x_hat = x + h + h1
        return x_hat, self.preference


class Base_gcn(MessagePassing):
    def __init__(self, in_channels, out_channels, normalize=True, bias=True, aggr='add', **kwargs):
        super(Base_gcn, self).__init__(aggr=aggr, **kwargs)
        self.aggr = aggr
        self.in_channels = in_channels
        self.out_channels = out_channels

    def forward(self, x, edge_index, size=None):
        # pdb.set_trace()
        if size is None:
            edge_index, _ = remove_self_loops(edge_index)
            # edge_index, _ = add_self_loops(edge_index, num_nodes=x.size(0))
        x = x.unsqueeze(-1) if x.dim() == 1 else x
        # pdb.set_trace()
        return self.propagate(edge_index, size=(x.size(0), x.size(0)), x=x)

    def message(self, x_j, edge_index, size):
        if self.aggr == 'add':
            # pdb.set_trace()
            row, col = edge_index
            deg = degree(row, size[0], dtype=x_j.dtype)
            # print('size[0]:', size[0])
            deg_inv_sqrt = deg.pow(-0.5)
            norm = deg_inv_sqrt[row] * deg_inv_sqrt[col]
            return norm.view(-1, 1) * x_j
        return x_j

    def update(self, aggr_out):
        return aggr_out

    def __repr(self):
        return '{}({},{})'.format(self.__class__.__name__, self.in_channels, self.out_channels)


